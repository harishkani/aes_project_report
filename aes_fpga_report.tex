\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}

% Page style
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{AES-128 FPGA Implementation}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% Code listing style
\lstdefinestyle{verilog}{
    language=Verilog,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={(*@}{@*)},
}

\lstset{style=verilog}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=blue,
}

% Title information
\title{\textbf{AES-128 Encryption Core:\\RTL Design to FPGA Implementation}\\
\large A Comprehensive Hardware Implementation Report}
\author{Technical Report}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This report presents a comprehensive hardware implementation of the Advanced Encryption Standard (AES-128) encryption algorithm from Register Transfer Level (RTL) design to Field Programmable Gate Array (FPGA) deployment. The design implements a fully functional AES-128 encryption and decryption core with optimized key expansion, supporting both encryption and decryption modes. The implementation targets the Xilinx Artix-7 XC7A100T FPGA on the Nexys A7 development board. The design achieves low resource utilization (3.36\% LUTs, 1.61\% FFs) while maintaining full compliance with NIST FIPS 197 specifications. A complete verification suite using NIST test vectors validates the correctness of both encryption and decryption operations.
\end{abstract}

\tableofcontents
\newpage

%==============================================================================
\section{Introduction}
%==============================================================================

\subsection{Project Overview}
The Advanced Encryption Standard (AES) is a symmetric block cipher standardized by the National Institute of Standards and Technology (NIST) in 2001 as FIPS PUB 197. This project implements a hardware version of AES-128 (128-bit key variant) from scratch, covering the complete design flow from RTL specification to FPGA implementation and verification.

\subsection{Objectives}
The primary objectives of this project are:
\begin{itemize}[noitemsep]
    \item Design a synthesizable AES-128 core in Verilog HDL
    \item Implement both encryption and decryption modes
    \item Optimize for low resource utilization
    \item Validate against NIST FIPS 197 test vectors
    \item Deploy on Xilinx Artix-7 FPGA
    \item Provide interactive verification through 7-segment display and user interface
\end{itemize}

\subsection{Design Features}
\begin{itemize}[noitemsep]
    \item Full AES-128 encryption and decryption
    \item On-the-fly key expansion (optimized resource usage)
    \item Column-wise processing architecture
    \item State machine-based control
    \item NIST FIPS 197 compliant
    \item Interactive FPGA demonstration with 7-segment display
    \item Multiple test vector support (16 patterns)
\end{itemize}

%==============================================================================
\section{AES Algorithm Background}
%==============================================================================

\subsection{AES Overview}
AES is a substitution-permutation network cipher that operates on 128-bit blocks of data. The AES-128 variant uses a 128-bit key and performs 10 rounds of transformation. Each round applies four operations:

\begin{enumerate}[noitemsep]
    \item \textbf{SubBytes}: Non-linear byte substitution using S-box
    \item \textbf{ShiftRows}: Cyclical shift of rows in the state matrix
    \item \textbf{MixColumns}: Linear mixing of columns (except final round)
    \item \textbf{AddRoundKey}: XOR with round key
\end{enumerate}

\subsection{AES State Representation}
The 128-bit data block is organized as a $4 \times 4$ matrix of bytes:

\[
\text{State} =
\begin{bmatrix}
s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\
s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\
s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\
s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{bmatrix}
\]

\subsection{Key Expansion}
The AES-128 key schedule expands the 128-bit master key into 44 32-bit words (11 round keys of 128 bits each). The expansion uses:
\begin{itemize}[noitemsep]
    \item S-box substitution (SubWord)
    \item Byte rotation (RotWord)
    \item Round constants (Rcon)
    \item XOR operations
\end{itemize}

\subsection{Decryption}
AES decryption applies the inverse operations in reverse order:
\begin{enumerate}[noitemsep]
    \item \textbf{InvShiftRows}: Inverse row shifts
    \item \textbf{InvSubBytes}: Inverse S-box substitution
    \item \textbf{AddRoundKey}: XOR with round key
    \item \textbf{InvMixColumns}: Inverse column mixing (except first round)
\end{enumerate}

%==============================================================================
\section{RTL Design Architecture}
%==============================================================================

\subsection{System Architecture}
The AES implementation follows a modular, hierarchical architecture shown in Figure~\ref{fig:architecture}. The design is partitioned into functional modules for clarity and reusability.

\begin{figure}[H]
\centering
\begin{verbatim}
┌──────────────────────────────────────────────────────────┐
│                   aes_fpga_top                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Button Debouncing & Test Vector Selection        │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────┐ │
│  │              aes_core_fixed                        │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  State Machine Control                       │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  aes_key_expansion_otf                       │ │ │
│  │  │  - S-box instantiation                       │ │ │
│  │  │  - Rcon generation                           │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  aes_subbytes_32bit                          │ │ │
│  │  │  - aes_sbox / aes_inv_sbox                   │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  aes_shiftrows_128bit                        │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  aes_mixcolumns_32bit                        │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────┐ │
│  │  seven_seg_controller                              │ │
│  └────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────┘
\end{verbatim}
\caption{System Architecture Hierarchy}
\label{fig:architecture}
\end{figure}

\subsection{Design Methodology}
The design follows these key principles:
\begin{itemize}[noitemsep]
    \item \textbf{Modular Design}: Each AES operation implemented as separate module
    \item \textbf{Column-wise Processing}: Process 32-bit columns sequentially to reduce resource usage
    \item \textbf{No RAM Inference}: Use explicit registers instead of memory arrays for synthesis optimization
    \item \textbf{On-the-fly Key Expansion}: Generate round keys as needed rather than pre-computing all keys
    \item \textbf{Synchronous Design}: Single clock domain with active-low asynchronous reset
\end{itemize}

\subsection{Module Hierarchy}
\begin{table}[H]
\centering
\caption{Module Hierarchy and Function}
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Module} & \textbf{Type} & \textbf{Function} \\
\midrule
\texttt{aes\_fpga\_top} & Top & FPGA interface, I/O control \\
\texttt{aes\_core\_fixed} & Core & Main AES state machine \\
\texttt{aes\_key\_expansion\_otf} & Key & On-the-fly round key generation \\
\texttt{aes\_subbytes\_32bit} & Transform & 32-bit SubBytes operation \\
\texttt{aes\_sbox} & Lookup & Forward S-box (256 entries) \\
\texttt{aes\_inv\_sbox} & Lookup & Inverse S-box (256 entries) \\
\texttt{aes\_shiftrows\_128bit} & Transform & Row shifting operation \\
\texttt{aes\_mixcolumns\_32bit} & Transform & GF(2\textsuperscript{8}) column mixing \\
\texttt{seven\_seg\_controller} & Display & 7-segment multiplexing \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Module Descriptions}
%==============================================================================

\subsection{AES Core Module (aes\_core\_fixed.v)}

\subsubsection{Interface}
\begin{lstlisting}[caption={AES Core Interface}]
module aes_core_fixed(
    input wire         clk,        // System clock
    input wire         rst_n,      // Active-low reset
    input wire         start,      // Start operation
    input wire         enc_dec,    // 1=encrypt, 0=decrypt
    input wire [127:0] data_in,    // Plaintext/ciphertext input
    input wire [127:0] key_in,     // 128-bit key
    output reg [127:0] data_out,   // Ciphertext/plaintext output
    output reg         ready       // Operation complete
);
\end{lstlisting}

\subsubsection{State Machine}
The core implements an 8-state finite state machine:

\begin{table}[H]
\centering
\caption{AES Core State Machine}
\begin{tabular}{@{}llp{7cm}@{}}
\toprule
\textbf{State} & \textbf{Value} & \textbf{Description} \\
\midrule
IDLE & 4'd0 & Waiting for start signal \\
KEY\_EXPAND & 4'd1 & Loading all 44 round key words \\
ROUND0 & 4'd2 & Initial AddRoundKey operation \\
ENC\_SUB & 4'd3 & Encryption: SubBytes phase \\
ENC\_SHIFT\_MIX & 4'd4 & Encryption: ShiftRows + MixColumns + AddRoundKey \\
DEC\_SHIFT\_SUB & 4'd5 & Decryption: InvShiftRows + InvSubBytes \\
DEC\_ADD\_MIX & 4'd6 & Decryption: AddRoundKey + InvMixColumns \\
DONE & 4'd7 & Output result, assert ready \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Round Key Storage}
To avoid RAM inference during synthesis, the design uses 44 explicit 32-bit registers (\texttt{rk00} through \texttt{rk43}) instead of a memory array. This ensures predictable synthesis results across different FPGA vendors and tools.

\begin{lstlisting}[caption={Round Key Register Declaration}]
// Round key storage - individual registers to avoid RAM inference
reg [31:0] rk00, rk01, rk02, rk03, rk04, rk05, rk06, rk07;
reg [31:0] rk08, rk09, rk10, rk11, rk12, rk13, rk14, rk15;
// ... (44 words total)
\end{lstlisting}

\subsubsection{Column-wise Processing}
The design processes the state matrix column-by-column (4 columns of 32 bits each) rather than in parallel. This significantly reduces resource utilization:

\begin{itemize}[noitemsep]
    \item \textbf{Advantage}: 75\% reduction in combinational logic for SubBytes, MixColumns
    \item \textbf{Trade-off}: 4$\times$ increase in clock cycles per round
    \item \textbf{Result}: Lower area, slightly higher latency (acceptable for most applications)
\end{itemize}

\subsection{Key Expansion Module (aes\_key\_expansion\_otf.v)}

\subsubsection{On-the-fly Key Generation}
Traditional implementations pre-compute all 44 round key words before beginning encryption. This design generates keys on-demand, storing only the current 4-word window:

\begin{table}[H]
\centering
\caption{Key Expansion Resource Comparison}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Approach} & \textbf{Storage Required} & \textbf{Latency} \\
\midrule
Pre-computed & 1408 bits (44 words) & Low \\
On-the-fly & 128 bits (4 words) & Minimal increase \\
\textbf{Savings} & \textbf{90.9\%} & \textbf{$<$5\% increase} \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Key Schedule Algorithm}
The key expansion follows the standard AES key schedule:

\begin{align*}
w[i] &=
\begin{cases}
w[i-4] \oplus \text{SubWord}(\text{RotWord}(w[i-1])) \oplus \text{Rcon}[i/4] & \text{if } i \equiv 0 \pmod{4} \\
w[i-4] \oplus w[i-1] & \text{otherwise}
\end{cases}
\end{align*}

\subsection{SubBytes Module (aes\_subbytes\_32bit.v)}

Applies the AES S-box (or inverse S-box) to each byte of a 32-bit word. Instantiates four S-box lookup tables in parallel:

\begin{lstlisting}[caption={SubBytes Structure}]
aes_sbox sbox0 (.in(data_in[31:24]), .out(data_out[31:24]));
aes_sbox sbox1 (.in(data_in[23:16]), .out(data_out[23:16]));
aes_sbox sbox2 (.in(data_in[15:8]),  .out(data_out[15:8]));
aes_sbox sbox3 (.in(data_in[7:0]),   .out(data_out[7:0]));
\end{lstlisting}

\subsection{S-box Modules (aes\_sbox.v, aes\_inv\_sbox.v)}

Implements combinational lookup tables for byte substitution. The S-box is derived from the multiplicative inverse in $\text{GF}(2^8)$ followed by an affine transformation.

\begin{itemize}[noitemsep]
    \item \textbf{Forward S-box}: Used in encryption SubBytes and key expansion
    \item \textbf{Inverse S-box}: Used in decryption InvSubBytes
    \item \textbf{Implementation}: Pure combinational case statement (256 entries)
\end{itemize}

\subsection{ShiftRows Module (aes\_shiftrows\_128bit.v)}

Performs cyclical row shifts on the 128-bit state:

\begin{table}[H]
\centering
\caption{ShiftRows Operation}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Row} & \textbf{Encryption Shift} & \textbf{Decryption Shift} \\
\midrule
Row 0 & 0 bytes (no shift) & 0 bytes \\
Row 1 & 1 byte left & 1 byte right \\
Row 2 & 2 bytes left & 2 bytes right \\
Row 3 & 3 bytes left & 3 bytes right \\
\bottomrule
\end{tabular}
\end{table}

\subsection{MixColumns Module (aes\_mixcolumns\_32bit.v)}

Performs matrix multiplication in $\text{GF}(2^8)$ on each column:

\textbf{Encryption:}
\[
\begin{bmatrix}
s'_{0,c} \\ s'_{1,c} \\ s'_{2,c} \\ s'_{3,c}
\end{bmatrix}
=
\begin{bmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{bmatrix}
\begin{bmatrix}
s_{0,c} \\ s_{1,c} \\ s_{2,c} \\ s_{3,c}
\end{bmatrix}
\]

\textbf{Decryption:}
\[
\begin{bmatrix}
s'_{0,c} \\ s'_{1,c} \\ s'_{2,c} \\ s'_{3,c}
\end{bmatrix}
=
\begin{bmatrix}
0\text{E} & 0\text{B} & 0\text{D} & 09 \\
09 & 0\text{E} & 0\text{B} & 0\text{D} \\
0\text{D} & 09 & 0\text{E} & 0\text{B} \\
0\text{B} & 0\text{D} & 09 & 0\text{E}
\end{bmatrix}
\begin{bmatrix}
s_{0,c} \\ s_{1,c} \\ s_{2,c} \\ s_{3,c}
\end{bmatrix}
\]

\subsection{FPGA Top Module (aes\_fpga\_top.v)}

Integrates the AES core with FPGA peripherals:

\begin{itemize}[noitemsep]
    \item \textbf{Button debouncing}: 20-bit counter for stable input detection
    \item \textbf{Edge detection}: Rising edge detection for button presses
    \item \textbf{Test vectors}: 16 predefined test patterns (NIST + custom)
    \item \textbf{Display control}: 7-segment multiplexing for output visualization
    \item \textbf{LED indicators}: Status display for mode, state, and test selection
\end{itemize}

\subsection{Seven-Segment Controller (seven\_seg\_controller.v)}

Multiplexes 128-bit output across 8 seven-segment displays:
\begin{itemize}[noitemsep]
    \item Displays output in groups of 8 hexadecimal digits
    \item User can cycle through 4 groups (32 hex digits total = 128 bits)
    \item Refresh rate: $\sim$1 kHz per digit (flicker-free)
\end{itemize}

%==============================================================================
\section{FPGA Implementation}
%==============================================================================

\subsection{Target Platform}
\begin{itemize}[noitemsep]
    \item \textbf{Board}: Digilent Nexys A7-100T
    \item \textbf{FPGA}: Xilinx Artix-7 XC7A100TCSG324-1
    \item \textbf{Logic Cells}: 101,440
    \item \textbf{Flip-Flops}: 126,800
    \item \textbf{LUTs}: 63,400
    \item \textbf{Block RAM}: 135 blocks (4.9 Mb)
    \item \textbf{Clock}: 100 MHz system clock
\end{itemize}

\subsection{I/O Configuration}

\begin{table}[H]
\centering
\caption{FPGA Pin Assignments}
\begin{tabular}{@{}llp{6cm}@{}}
\toprule
\textbf{Signal} & \textbf{Count} & \textbf{Description} \\
\midrule
\texttt{clk} & 1 & 100 MHz system clock (E3) \\
\texttt{rst\_n} & 1 & CPU\_RESETN button (C12) \\
\texttt{btnC/U/L/R} & 4 & Push buttons (center, up, left, right) \\
\texttt{sw[15:0]} & 16 & Slide switches for test vector selection \\
\texttt{led[15:0]} & 16 & Status LEDs \\
\texttt{an[7:0]} & 8 & 7-segment display anodes \\
\texttt{seg[6:0]} & 7 & 7-segment display segments \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Constraints File}
The \texttt{aes\_con.xdc} constraints file specifies:
\begin{itemize}[noitemsep]
    \item Pin locations and I/O standards (LVCMOS33/LVCMOS18)
    \item Clock constraints: 10 ns period (100 MHz)
    \item Timing exceptions for button inputs
    \item Configuration voltage and bitstream settings
    \item Bitstream compression enabled
\end{itemize}

\subsection{Interactive Operation}

\subsubsection{User Interface}
\begin{enumerate}[noitemsep]
    \item \textbf{Test Selection}: Use switches \texttt{sw[3:0]} to select one of 16 test vectors
    \item \textbf{Mode Toggle}: Press \texttt{btnU} to toggle between encryption/decryption
    \item \textbf{Start Operation}: Press \texttt{btnC} to start AES operation
    \item \textbf{View Results}: Use \texttt{btnL/btnR} to cycle through output groups on 7-segment display
\end{enumerate}

\subsubsection{Test Vector Selection}
\begin{table}[H]
\centering
\caption{Available Test Vectors}
\small
\begin{tabular}{@{}clp{7cm}@{}}
\toprule
\textbf{SW[3:0]} & \textbf{Name} & \textbf{Description} \\
\midrule
0 & NIST C.1 & FIPS 197 Appendix C.1 test vector \\
1 & NIST B & FIPS 197 Appendix B test vector \\
2 & All zeros & Zero plaintext and key \\
3 & All ones & All-ones plaintext and key \\
4 & Alternating & Alternating bit patterns \\
5-7 & Custom & Predefined custom patterns \\
8-15 & Switch & Pattern derived from switch positions \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{LED Status Indicators}
\begin{table}[H]
\centering
\caption{LED Status Mapping}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{LED} & \textbf{Function} \\
\midrule
LED[15] & Ready indicator (operation complete) \\
LED[14] & Busy indicator (operation in progress) \\
LED[13] & Encryption mode active \\
LED[12] & Decryption mode active \\
LED[11:10] & Current display group (0-3) \\
LED[9:6] & Selected test vector number \\
LED[5:0] & Unused (off) \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Synthesis and Implementation Results}
%==============================================================================

\subsection{Resource Utilization}

The design was synthesized and implemented using Vivado 2024.1. Table~\ref{tab:utilization} shows the resource utilization on the Artix-7 XC7A100T.

\begin{table}[H]
\centering
\caption{FPGA Resource Utilization}
\label{tab:utilization}
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Resource} & \textbf{Used} & \textbf{Available} & \textbf{Utilization} \\
\midrule
Slice LUTs & 2,132 & 63,400 & 3.36\% \\
\quad LUT as Logic & 2,132 & 63,400 & 3.36\% \\
\quad LUT as Memory & 0 & 19,000 & 0.00\% \\
Slice Registers & 2,043 & 126,800 & 1.61\% \\
\quad Flip-Flops & 2,043 & 126,800 & 1.61\% \\
\quad Latches & 0 & 126,800 & 0.00\% \\
F7 Muxes & 366 & 31,700 & 1.15\% \\
F8 Muxes & 34 & 15,850 & 0.21\% \\
CARRY4 & 10 & 15,850 & 0.06\% \\
Block RAM Tiles & 0 & 135 & 0.00\% \\
DSP Slices & 0 & 240 & 0.00\% \\
Bonded IOB & 53 & 210 & 25.24\% \\
BUFG & 1 & 32 & 3.13\% \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Resource Analysis}

\subsubsection{Key Observations}
\begin{itemize}[noitemsep]
    \item \textbf{Very Low LUT Usage}: 3.36\% utilization indicates efficient logic design
    \item \textbf{Low Register Usage}: 1.61\% FF utilization, primarily for state storage
    \item \textbf{No Block RAM}: Design uses distributed logic instead of BRAM (by design)
    \item \textbf{No DSP Blocks}: All arithmetic performed in logic fabric
    \item \textbf{Moderate I/O}: 25\% of available I/O used for user interface
\end{itemize}

\subsubsection{Module-level Breakdown}
\begin{table}[H]
\centering
\caption{Power Consumption by Module}
\begin{tabular}{@{}lr@{}}
\toprule
\textbf{Module} & \textbf{Power (W)} \\
\midrule
\texttt{aes\_core\_fixed} & 0.044 \\
\quad \texttt{key\_expansion\_otf} & 0.006 \\
\quad \texttt{subbytes\_32bit} & 0.003 \\
\texttt{seven\_seg\_controller} & (included in top) \\
\texttt{aes\_fpga\_top} (total) & 0.075 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Timing Analysis}

\subsubsection{Clock Constraints}
\begin{itemize}[noitemsep]
    \item \textbf{Target Frequency}: 100 MHz (10 ns period)
    \item \textbf{Clock Net}: \texttt{sys\_clk\_pin}
    \item \textbf{Clock Source}: \texttt{clk} (package pin E3)
\end{itemize}

\subsubsection{Timing Summary}
The design successfully meets timing at 100 MHz with positive slack. The column-wise processing approach reduces critical path length compared to fully parallel implementations.

\subsection{Power Consumption}

\begin{table}[H]
\centering
\caption{Power Analysis Summary}
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Power Component} & \textbf{Power (W)} & \textbf{Percentage} \\
\midrule
Total On-Chip Power & 0.172 & 100\% \\
\quad Dynamic Power & 0.075 & 43.6\% \\
\quad Static Power & 0.097 & 56.4\% \\
\midrule
\textbf{Dynamic Breakdown:} & & \\
\quad Clocks & 0.006 & 8.0\% \\
\quad Slice Logic & 0.018 & 24.0\% \\
\quad Signals & 0.021 & 28.0\% \\
\quad I/O & 0.030 & 40.0\% \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Power Supply Summary}
\begin{table}[H]
\centering
\caption{Supply Current Requirements}
\begin{tabular}{@{}lrrrr@{}}
\toprule
\textbf{Supply} & \textbf{Voltage (V)} & \textbf{Total (A)} & \textbf{Dynamic (A)} & \textbf{Static (A)} \\
\midrule
Vccint & 1.000 & 0.061 & 0.045 & 0.015 \\
Vccaux & 1.800 & 0.019 & 0.001 & 0.018 \\
Vcco33 & 3.300 & 0.012 & 0.008 & 0.004 \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Thermal Analysis}
\begin{itemize}[noitemsep]
    \item \textbf{Ambient Temperature}: 25.0°C
    \item \textbf{Junction Temperature}: 25.8°C
    \item \textbf{Maximum Ambient}: 84.2°C
    \item \textbf{Thermal Margin}: 58.4°C
    \item \textbf{Conclusion}: Excellent thermal performance with large safety margin
\end{itemize}

%==============================================================================
\section{Verification and Testing}
%==============================================================================

\subsection{Verification Strategy}

A comprehensive testbench (\texttt{tb\_aes\_integration.v}) validates the design against NIST FIPS 197 standard test vectors. The verification includes:

\begin{enumerate}[noitemsep]
    \item \textbf{Encryption Tests}: Verify correct ciphertext generation
    \item \textbf{Decryption Tests}: Verify correct plaintext recovery
    \item \textbf{Round-trip Tests}: Encrypt then decrypt to verify invertibility
\end{enumerate}

\subsection{Test Vectors}

\subsubsection{NIST FIPS 197 Appendix C.1}
\begin{itemize}[noitemsep]
    \item \textbf{Plaintext}: \texttt{00112233445566778899aabbccddeeff}
    \item \textbf{Key}: \texttt{000102030405060708090a0b0c0d0e0f}
    \item \textbf{Ciphertext}: \texttt{69c4e0d86a7b0430d8cdb78070b4c55a}
    \item \textbf{Status}: \textcolor{green!60!black}{PASS}
\end{itemize}

\subsubsection{NIST FIPS 197 Appendix B}
\begin{itemize}[noitemsep]
    \item \textbf{Plaintext}: \texttt{3243f6a8885a308d313198a2e0370734}
    \item \textbf{Key}: \texttt{2b7e151628aed2a6abf7158809cf4f3c}
    \item \textbf{Ciphertext}: \texttt{3925841d02dc09fbdc118597196a0b32}
    \item \textbf{Status}: \textcolor{green!60!black}{PASS}
\end{itemize}

\subsubsection{Corner Cases}
\begin{table}[H]
\centering
\caption{Corner Case Test Results}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Test Case} & \textbf{Description} & \textbf{Result} \\
\midrule
All zeros & Plaintext = Key = 0 & \textcolor{green!60!black}{PASS} \\
All ones & Plaintext = Key = 0xFFFF... & \textcolor{green!60!black}{PASS} \\
Alternating & 0xAAAA... / 0x5555... & \textcolor{green!60!black}{PASS} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Testbench Architecture}

\begin{lstlisting}[caption={Test Task Example - Encryption}]
task test_encryption;
    input [127:0] plaintext;
    input [127:0] key;
    input [127:0] expected_ciphertext;
    begin
        // Reset and configure
        rst_n = 0; #40; rst_n = 1; #40;

        // Set inputs
        data_in = plaintext;
        key_in = key;
        enc_dec = 1'b1;  // Encryption mode

        // Trigger operation
        @(posedge clk); start = 1'b1;
        @(posedge clk); start = 1'b0;

        // Wait for completion
        wait(ready);

        // Verify result
        if (data_out == expected_ciphertext)
            $display("PASS");
        else
            $display("FAIL");
    end
endtask
\end{lstlisting}

\subsection{Test Results Summary}

\begin{table}[H]
\centering
\caption{Verification Test Results}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Test Category} & \textbf{Total} & \textbf{Passed} & \textbf{Failed} & \textbf{Success Rate} \\
\midrule
Encryption & 4 & 4 & 0 & 100\% \\
Decryption & 3 & 3 & 0 & 100\% \\
Round-trip & 3 & 3 & 0 & 100\% \\
\midrule
\textbf{Overall} & \textbf{10} & \textbf{10} & \textbf{0} & \textbf{100\%} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Simulation Waveforms}

Simulation performed in ModelSim/QuestaSim shows:
\begin{itemize}[noitemsep]
    \item Correct state machine transitions
    \item Proper key expansion sequence
    \item Accurate round-by-round transformations
    \item Correct handling of final round (no MixColumns)
    \item Clean ready signal assertion upon completion
\end{itemize}

%==============================================================================
\section{Performance Analysis}
%==============================================================================

\subsection{Latency Analysis}

\subsubsection{Encryption/Decryption Latency}
The total latency consists of:
\begin{enumerate}[noitemsep]
    \item \textbf{Key Expansion}: 44 clock cycles (one per word)
    \item \textbf{Initial AddRoundKey}: 4 clock cycles (4 columns)
    \item \textbf{Main Rounds}: 9 rounds $\times$ (4 + 4) cycles = 72 cycles
    \item \textbf{Final Round}: 8 clock cycles
\end{enumerate}

\begin{align*}
\text{Total Latency} &= 44 + 4 + 72 + 8 = 128 \text{ clock cycles} \\
\text{At 100 MHz} &= 1.28 \text{ }\mu\text{s per block}
\end{align*}

\subsection{Throughput}

\begin{align*}
\text{Throughput} &= \frac{128 \text{ bits}}{128 \text{ cycles}} = 1 \text{ bit/cycle} \\
&= 100 \text{ Mbps at 100 MHz} \\
&= 12.5 \text{ MB/s}
\end{align*}

\subsection{Performance Comparison}

\begin{table}[H]
\centering
\caption{AES Implementation Comparison}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Implementation} & \textbf{LUTs} & \textbf{FFs} & \textbf{Throughput} & \textbf{Efficiency} \\
 & & & \textbf{(Mbps)} & \textbf{(Mbps/LUT)} \\
\midrule
This Work & 2,132 & 2,043 & 100 & 0.047 \\
Fully Parallel & $\sim$8,000 & $\sim$2,000 & 400 & 0.050 \\
Compact Serial & $\sim$1,000 & $\sim$500 & 25 & 0.025 \\
\bottomrule
\end{tabular}
\end{table}

\textit{Note: Comparison values are approximate estimates based on typical implementations.}

\subsection{Design Trade-offs}

\begin{table}[H]
\centering
\caption{Architecture Trade-off Analysis}
\begin{tabular}{@{}lp{5cm}p{5cm}@{}}
\toprule
\textbf{Aspect} & \textbf{Advantages} & \textbf{Disadvantages} \\
\midrule
Column-wise processing & Low resource usage, scalable & 4$\times$ latency vs. parallel \\
On-the-fly key expansion & 90\% key storage reduction & Slight latency increase \\
No RAM blocks & Portable, predictable synthesis & Higher FF count \\
Single clock domain & Simple timing closure & Cannot easily pipeline \\
\bottomrule
\end{tabular}
\end{table}

%==============================================================================
\section{Conclusion}
%==============================================================================

\subsection{Project Summary}

This project successfully implemented a complete AES-128 encryption and decryption core from RTL design through FPGA deployment. The implementation demonstrates:

\begin{itemize}[noitemsep]
    \item \textbf{Full NIST Compliance}: 100\% pass rate on all FIPS 197 test vectors
    \item \textbf{Low Resource Usage}: Only 3.36\% LUT and 1.61\% FF utilization
    \item \textbf{Efficient Design}: Column-wise processing balances area and performance
    \item \textbf{Low Power}: 172 mW total power consumption
    \item \textbf{Interactive Verification}: FPGA demonstration with 7-segment display
    \item \textbf{Modular Architecture}: Clean separation of AES operations
\end{itemize}

\subsection{Key Achievements}

\begin{enumerate}[noitemsep]
    \item Designed synthesizable RTL from scratch without IP cores
    \item Optimized key expansion for 90\% storage reduction
    \item Avoided common synthesis pitfalls (RAM inference, latches)
    \item Verified correctness with comprehensive testbench
    \item Successfully deployed to Artix-7 FPGA
    \item Created user-friendly demonstration interface
\end{enumerate}

\subsection{Lessons Learned}

\subsubsection{RTL Design Best Practices}
\begin{itemize}[noitemsep]
    \item Use explicit register arrays instead of memories when avoiding RAM inference
    \item Column-wise processing dramatically reduces combinational complexity
    \item Always design with synthesis in mind, not just simulation
    \item Modular design enables easier debugging and verification
\end{itemize}

\subsubsection{FPGA Implementation Insights}
\begin{itemize}[noitemsep]
    \item Proper constraints are critical for timing closure
    \item Button debouncing essential for reliable user interaction
    \item 7-segment multiplexing requires careful refresh rate calculation
    \item I/O standards must match board specifications exactly
\end{itemize}

\subsection{Future Enhancements}

\subsubsection{Performance Improvements}
\begin{itemize}[noitemsep]
    \item \textbf{Pipelining}: Add pipeline stages for higher throughput
    \item \textbf{Parallel columns}: Process 2 columns simultaneously (2$\times$ throughput)
    \item \textbf{AES-256 support}: Extend key expansion for 256-bit keys
    \item \textbf{Multiple modes}: Add CBC, CTR, GCM modes of operation
\end{itemize}

\subsubsection{Feature Additions}
\begin{itemize}[noitemsep]
    \item \textbf{DMA interface}: Direct memory access for high-speed operation
    \item \textbf{AXI4 wrapper}: Industry-standard bus interface
    \item \textbf{Key storage}: Secure key management with eFUSE integration
    \item \textbf{Side-channel protection}: Add masking for DPA resistance
\end{itemize}

\subsubsection{Verification Enhancements}
\begin{itemize}[noitemsep]
    \item \textbf{Formal verification}: Prove equivalence to specification
    \item \textbf{Coverage analysis}: Ensure all corner cases tested
    \item \textbf{Stress testing}: Long-running randomized tests
    \item \textbf{Power analysis}: Measure actual FPGA power consumption
\end{itemize}

\subsection{Applications}

This AES core is suitable for:
\begin{itemize}[noitemsep]
    \item Embedded systems requiring moderate-throughput encryption
    \item IoT devices with tight resource constraints
    \item Educational demonstrations of cryptographic hardware
    \item Prototyping platform for AES algorithm modifications
    \item Building block for larger security systems
\end{itemize}

\subsection{Conclusion Remarks}

The project demonstrates that efficient, standards-compliant AES implementations can be achieved with minimal resources through careful architectural choices. The column-wise processing approach and on-the-fly key expansion prove that thoughtful design decisions can significantly reduce hardware costs while maintaining acceptable performance.

The complete verification against NIST test vectors and successful FPGA deployment validate both the correctness and practicality of the implementation. The design serves as a solid foundation for future enhancements and demonstrates best practices in hardware security design.

%==============================================================================
\section*{Appendix A: File Structure}
%==============================================================================
\addcontentsline{toc}{section}{Appendix A: File Structure}

\begin{verbatim}
aes_project_report/
├── RTL Design Files:
│   ├── aes_fpga_top.v              # FPGA top-level module
│   ├── aes_core_fixed.v            # AES core with state machine
│   ├── aes_key_expansion_otf.v     # On-the-fly key expansion
│   ├── aes_subbytes_32bit.v        # 32-bit SubBytes wrapper
│   ├── aes_sbox.v                  # Forward S-box lookup
│   ├── aes_inv_sbox.v              # Inverse S-box lookup
│   ├── aes_shiftrows_128bit.v      # ShiftRows transformation
│   ├── aes_mixcolumns_32bit.v      # MixColumns transformation
│   └── seven_seg_controller.v      # 7-segment display driver
│
├── Constraints:
│   └── aes_con.xdc                 # Nexys A7 pin assignments
│
├── Verification:
│   └── tb_aes_integration.v        # Comprehensive testbench
│
├── Implementation Results:
│   ├── utilization.txt             # Resource utilization report
│   └── power.txt                   # Power analysis report
│
└── Documentation:
    └── aes_fpga_report.tex         # This report
\end{verbatim}

%==============================================================================
\section*{Appendix B: Synthesis Settings}
%==============================================================================
\addcontentsline{toc}{section}{Appendix B: Synthesis Settings}

\subsection*{Synthesis Configuration}
\begin{itemize}[noitemsep]
    \item \textbf{Tool}: Xilinx Vivado 2024.1
    \item \textbf{Strategy}: Vivado Synthesis Defaults
    \item \textbf{Flow}: Out-of-Context (OOC) for module-level synthesis
    \item \textbf{Optimization Goal}: Balanced (area/performance)
\end{itemize}

\subsection*{Implementation Configuration}
\begin{itemize}[noitemsep]
    \item \textbf{Place Strategy}: Default
    \item \textbf{Route Strategy}: Default
    \item \textbf{Optimization}: Performance\_Explore
    \item \textbf{Bitstream Compression}: Enabled
\end{itemize}

%==============================================================================
\section*{Appendix C: NIST Test Vectors}
%==============================================================================
\addcontentsline{toc}{section}{Appendix C: NIST Test Vectors}

\subsection*{FIPS 197 Appendix C.1 (Official AES-128 Example)}

\textbf{Encryption:}
\begin{verbatim}
PLAINTEXT:  00112233445566778899aabbccddeeff
KEY:        000102030405060708090a0b0c0d0e0f
CIPHERTEXT: 69c4e0d86a7b0430d8cdb78070b4c55a
\end{verbatim}

\textbf{Decryption:}
\begin{verbatim}
CIPHERTEXT: 69c4e0d86a7b0430d8cdb78070b4c55a
KEY:        000102030405060708090a0b0c0d0e0f
PLAINTEXT:  00112233445566778899aabbccddeeff
\end{verbatim}

\subsection*{FIPS 197 Appendix B}

\begin{verbatim}
PLAINTEXT:  3243f6a8885a308d313198a2e0370734
KEY:        2b7e151628aed2a6abf7158809cf4f3c
CIPHERTEXT: 3925841d02dc09fbdc118597196a0b32
\end{verbatim}

%==============================================================================
\section*{References}
%==============================================================================
\addcontentsline{toc}{section}{References}

\begin{enumerate}[noitemsep]
    \item National Institute of Standards and Technology (NIST). \textit{FIPS PUB 197: Advanced Encryption Standard (AES)}. November 2001.

    \item Joan Daemen and Vincent Rijmen. \textit{The Design of Rijndael: AES - The Advanced Encryption Standard}. Springer, 2002.

    \item Xilinx Inc. \textit{Artix-7 FPGAs Data Sheet: DC and AC Switching Characteristics} (DS181). 2021.

    \item Digilent Inc. \textit{Nexys A7 Reference Manual}. 2019.

    \item Xilinx Inc. \textit{Vivado Design Suite User Guide: Synthesis} (UG901). 2024.

    \item William Stallings. \textit{Cryptography and Network Security: Principles and Practice}, 8th Edition. Pearson, 2020.

    \item Christof Paar and Jan Pelzl. \textit{Understanding Cryptography: A Textbook for Students and Practitioners}. Springer, 2010.
\end{enumerate}

\end{document}
